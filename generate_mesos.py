import sys, subprocess, os, zipfile, threading, time, struct

# Maximum number of processing threads to use
# idat64.exe fails silently on OOMs and stuff so we just keep this reasonable
MAX_JOBS = 4

# Name of the input zip file created by `offline_meso.ps1`
PREP_ZIP = "meso_deps.zip"

# Name of IDA executable
IDA_NAME = "idat64.exe"

# Name of the folder to write the mesos to
CACHE_FOLDER_NAME = "cache"

def usage():
    print("Usage:")
    print("    generate_mesos.py process_ida")
    print("        Processes all files in the meso_deps.zip file\n")

    print("    generate_mesos.py process_ida_whitelist <str 1> <str 2> <str ...>")
    print("        Processes files only containing one of the strings provided\n")

    print("    generate_mesos.py process_ida_blacklist <str 1> <str 2> <str ...>")
    print("        Processes files all files except for those containing one of the provided strings\n")

    print("Examples:\n")
    print("    python generate_mesos.py process_ida_whitelist system32")
    print("        Only processes files in `system32`\n")
    print("    python generate_mesos.py process_ida_blacklist ntdll.dll")
    print("        Process all files except for `ntdll.dll`\n")

    print("Path requirements for process_ida_*: must have `idat64.exe` in your PATH")
    quit()

def process_ida(orig_name, cache_fn, cache_fn_bin, contents):
    if not os.path.exists(cache_fn):
        # Make the hirearchy for the cache file
        try:
            os.makedirs(os.path.dirname(cache_fn))
        except FileExistsError:
            pass

        # Save file to disk
        with open(cache_fn_bin, "wb") as fd:
            fd.write(contents)

        try:
            # Invoke IDA to generate the meso file
            subprocess.check_call([
                IDA_NAME, "-o%s.idb" % cache_fn, "-A",
                "-Smesogen_scripts/ida.py cmdline \"%s\" \"%s\"" % \
                        (cache_fn, os.path.basename(orig_name)),
                "-c", cache_fn_bin], shell=True)
        except FileNotFoundError:
            print("Could not find idat64.exe, is it not in your path?")
            quit(-1)

def process(whitelist, blacklist):
    # Open the zip file generated by an offline meso script
    tf = zipfile.ZipFile(PREP_ZIP, "r")

    for member in tf.infolist():
        # If there's no file size (it's a directory) skip it
        if member.file_size == 0:
            continue

        # Check if the blacklist excludes this file
        if blacklist is not None:
            in_blacklist = filter(lambda x: x in member.filename, blacklist)
            if len(list(in_blacklist)) > 0:
                continue

        # Check if the whitelist includes a file
        if whitelist is not None:
            in_whitelist = filter(lambda x: x in member.filename, whitelist)
            if len(list(in_whitelist)) == 0:
                continue
        
        print("Processing %s" % member.filename)

        # Read the file from the archive
        contents = None
        with tf.open(member, "r") as fd:
            contents = fd.read()

        # Parse out the TimeDateStamp and SizeOfImage from the PE header
        assert contents[:2] == b"MZ"
        pe_ptr = struct.unpack("<I", contents[0x3c:0x40])[0]
        assert contents[pe_ptr:pe_ptr+4] == b"PE\0\0"
        time_date_stamp = \
                struct.unpack("<I", contents[pe_ptr+8:pe_ptr+0xc])[0]
        size_of_image = \
                struct.unpack("<I", contents[pe_ptr+0x50:pe_ptr+0x54])[0]

        image_name = os.path.split(member.filename)[1]

        # Compute meso and binary names for the cache folder
        cache_fn = os.path.join(CACHE_FOLDER_NAME, "%s_%x_%x.meso" % \
                (image_name, time_date_stamp, size_of_image))
        cache_fn_bin = os.path.join(CACHE_FOLDER_NAME, "%s_%x_%x" % \
                (image_name, time_date_stamp, size_of_image))

        # Limit number of active threads
        while threading.active_count() > MAX_JOBS:
            time.sleep(0.1)

        # Create thread
        threading.Timer(0.0, process_ida, \
                args=[image_name, cache_fn, cache_fn_bin, contents]) \
                .start()

    # Wait for all jobs to finish
    while threading.active_count() > 1:
        time.sleep(0.1)

if len(sys.argv) == 2 and sys.argv[1] == "process_ida":
    process(None, None)
elif len(sys.argv) >= 2 and sys.argv[1] == "process_ida_whitelist":
    process(sys.argv[2:], None)
elif len(sys.argv) >= 2 and sys.argv[1] == "process_ida_blacklist":
    process(None, sys.argv[2:])
else:
    usage()

